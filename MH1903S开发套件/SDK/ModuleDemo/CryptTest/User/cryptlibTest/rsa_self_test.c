#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "mhscpu.h"

/*
typedef struct
{
    uint32_t eta[32];
    uint32_t ro[32];
    uint32_t pi[32];
}mh_rsa_efc_para_def;
*/
//extern uint32_t mh_rsa_gen_efc_para(mh_rsa_efc_para_def *efc, uint32_t *qmin, uint32_t *qmax, uint32_t qlen);
//extern uint32_t mh_rsa_gen_key(mh_rsa_private_key *key, uint32_t exponent, uint32_t nbits);

/*
 * Example RSA-2048 keypair, for test purposes
 */


#define PLAIN "1234567890"


#define KEY_LEN_1024               1024 / 32
#define RSA_N_1024          "CDE42E9228172CBE4C542194BBB112728E0180FF7196B849D74F0630ED92AA5C4E04224E10C43881EBD710151E1F6BE47B2F688EAB880AC3D876C9702378CB524CA85637DE795D4393D129672DB4655C1EE82959ED051A92C1902135751CC4EC3E5B9050D5DF7A40610F61E382D864CC85F49F676E7C58A56E275D32648A65AB"
#define RSA_E_1024          "00010001"
#define RSA_D_1024          "B5C1ED76EB5B620D709688BAA362F3351BB5AA2A571D45FD31CCBA5B712F1BA3B6DFA165271A020477AD78AE1BD4834BC58F998EF1507CA85DACA7B18E2EF1D5548723BD59DF8DA9B108DA2B5A455E9F3F12CD2DC0E549FF3EA534E0690AA393042062290931FA2B5AC1E9A1753C4791D74641103AFF067F7DD86B02C768CC59"
#define RSA_P_1024          "F2DEB75C74A29F4FB17405ED8B584E63839F1822029FADB86AB4AAEA5E76E915503BB6C44BCE3194026FFF47170D3725AEC18B99348DB40B6B5522FAB81CE3A7"
#define RSA_Q_1024          "D905AFCF9AEEDAE746550927BA6B3C8A32EDEE8C16DC8306027FF54C159CBC847DF4FD4841FFF57E50E8A675C9CAC2428C2BD75B00B7BA74243F3898DBF4FE5D"
#define RSA_DP_1024         "4A1B14FDDC04E6F16D2706CC0591AB51880EDA513E55B4AF29B7F8D2CC8221FAC3E18491FEC36AB34BCF1AA8796B29E190A233D34A8AD65E09A10FAC4AD35DCF"
#define RSA_DQ_1024         "06CB8AC9B14C314674894D14155E2E33158D259EF5484A41F1EA17C01E1D1E39F7C7A7F68F3A7871500F38C70F5E6DDEAF8CDFDD55946B1E1FD46AED3E55D971"
#define RSA_QP_1024         "7E4BDC3E7FA115F1AEFD49CE2FFA474E4777FFA5195A6909919DD093CFACDC98A13C72EFA2476F148E6BE7F330E4143BEDF8B9D965D3A3A2657890049DE98635"
#define RSA_N_C_1024        "64EFEDD782B6A49AEA1872EDD9275E49931139CCFF5AC92433B07B0A9EA6693FA7C9D1B3149E17C8DD0A1AB8548844EB6E0F50DC894AF0593E4E5B7E27690FB576642F98A1A33C22FF382DAFAEAECDFFDDFD3DD09A207C5B335DEC99C5D137426421E044312602DA6901A218EAB977D6A5C7B5A60191A4BDE0DBC63C407FEF8D"
#define RSA_P_C_1024        "5DA1CD5FA89C67FA7728E97B67BAAE72D1A9F03E7CC032ADB9EDAC3949667F4B04A1196D73F5D8A375B9E7E13A95D7F934ABB508EC96DE712644621864CB94B8"
#define RSA_Q_C_1024        "4017B2E1F5500979E663ECE3A049678E49BCD4C822BE2E2C6C6C815A2EC23F5EEE7C153C6A2C2677F2419792F2BA6BE8B4C42943267922BF02B02AAAE7071E23"
#define RSA_N_Q_1024        "85BA92FD"
#define RSA_P_Q_1024        "3AC26BE9"
#define RSA_Q_Q_1024        "98B83A0B"
#define CIPHER_1024         "4257A706BDB0F1AEF8957E5B00ADB1BB2386AAC79394180049AF03C5AE12642E20D33D725408E361FBB600871E0AD925DAB6AA76CE6324E9189B33C99106BA45317FD8639EAF2F6DCA03DEA33D0DCE37D9493F917A1DB8A47F4FC249D44B22775D12908BE2F8F95A8451A0738A9961BD4E905741AB6A16EA2D600A5BB95AF399"

#define PLAIN_1024          "2D3AC6780E3923927044A949B09AAC72DD57E8AAB4971501000908A1630000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
#define KEY_LEN_1024        1024 / 32
#define RSA_N_1024          "BC453A58AEF25D5F83DA8B800BC929D5391EF1BA68D96D6EC7D7C6CDF3D3396AAEDF6C7A6F723EC68663EE07800FD1AF5E2C49CEAA069CFD92E72DA868A5036315E3DA49A7FBC2F6E4290760B0808BBBA253DC3E3C6322CF8C479B359ADB02CBF2928C24D5AEC798C912A629222ED5D2152F580FA4C8455D42544A3D4E4AC83D"
#define RSA_E_1024          "00010001"
#define RSA_D_1024          "1219258EB8E29B8F3F01973F6BE29E9EDCAAD8D9EE92582EBA0F48112C4B35CDC799BAB7DA56C52A18692ACC95C6EF85482C41BC1824229B4DAFE377B8F783E7AC488EDEAE44CB07286FAEDBE92EA3F19056E8F8584816EF63B3A82894B152D9914F45F5A17FCA13C2C3192246FCF7E3A2866EA0F47BDE919393A750FF564501"
#define RSA_P_1024          "D2BC37A22B379B67CEAE4FF7C5802EEE001A10405499E481B5BC1075B10E0BDA2E533A7367310A5722224D793599D97A3B715DAD919D856B960C4F9722DBAE91"
#define RSA_Q_1024          "E4B5BABDB58392D64C4D65819F5119574B15D28610140B200EA8F7A43F3818CC36A41F9818F0059ADA2F6A82BBB02CEB036E4966FCB3F8C6300D05ACE3756CED"
#define RSA_DP_1024         "BD3A053AB953D558015EC4AFD7C8A25B53FC135BB09BFF73F99C45AB68B11433762585F6DA524ED6AEEFDE6158A02D887497F76643BB0E72ECE9610E755E8E01"
#define RSA_DQ_1024         "868C6EE6CA513462441348432091DA61A3779C19687E122972D66E91BEEB66934515FACC44E777B4A8E53A38DCE80114E538CD8FFBDC78DF474771EE4B063AE5"
#define RSA_QP_1024         "615A691762362DFFE04C345CC60E8998B9A93D6D7DD110CCE69149F88E3261187E43889562E7A5628822948DE33EDFE1B6C4DB04AAF87D786F5CF9906A762C14"
#define RSA_N_C_1024        "7302B7A33C83618D3E49BF9B600D99DDF9600BF06FB8A59DC923E91244FE7E411581E3E8CCFC6651271D1EC0A135B0A63AEF5705F8AEC7D0D93DBE779176C1BA28F6E4C439395EF7D7A7FDC48A3D532CBDA75751BAC568A67560D65A585FB22663F3BA2BE2CDA97FF5E7D58171322FD41146B8FF8CAA9F1938E38795B75FBB5C"
#define RSA_P_C_1024        "1B79AE5A8692E52D05180A89A204684BC41AD57C9FA17270AEBBEA7C064D209A1A6208998695BEB236AD763FAC09153FDE4E74D20DED301D38D6707F732BA9A1"
#define RSA_Q_C_1024        "8F5F9FC2DB57FC68A2E6C1340C651DABF1A4DEBD04E5933B39644E8306A4D95BBA279DB8F40C5C479C3352D9A63D43811365EAB9473B78B2F9155D1EBD686218"
#define RSA_N_Q_1024        "E535F0EB"
#define RSA_P_Q_1024        "70FA2D8F"
#define RSA_Q_Q_1024        "CC562F1B"
#define CIPHER_1024         "36949D3DEEC431ADA4A471D9752CD208F1EF30BD49D88586461FA1D8652B753EC8DA7EC1BAC215818BD43E3D4CB88E9D58EA7058E0F20C94DED069C7D32AFC563DA92B0BC41AC5FCA0985262938F373C319F7A3FDAEE30D96BB858CD8A16A390A23A4FC72B153A63D8BA21F491898AF1420D8F77D67AFC10AABBA186D35397BF"

#define PLAIN_1024          "0000AF087C93255BA8E6EA1A8153FA21092589A13CB69B660100090854740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
#define KEY_LEN_1024        1024 / 32
#define RSA_N_1024          "BC453A58AEF25D5F83DA8B800BC929D5391EF1BA68D96D6EC7D7C6CDF3D3396AAEDF6C7A6F723EC68663EE07800FD1AF5E2C49CEAA069CFD92E72DA868A5036315E3DA49A7FBC2F6E4290760B0808BBBA253DC3E3C6322CF8C479B359ADB02CBF2928C24D5AEC798C912A629222ED5D2152F580FA4C8455D42544A3D4E4AC83D"
#define RSA_E_1024          "00010001"
#define RSA_D_1024          "1219258EB8E29B8F3F01973F6BE29E9EDCAAD8D9EE92582EBA0F48112C4B35CDC799BAB7DA56C52A18692ACC95C6EF85482C41BC1824229B4DAFE377B8F783E7AC488EDEAE44CB07286FAEDBE92EA3F19056E8F8584816EF63B3A82894B152D9914F45F5A17FCA13C2C3192246FCF7E3A2866EA0F47BDE919393A750FF564501"
#define RSA_P_1024          "D2BC37A22B379B67CEAE4FF7C5802EEE001A10405499E481B5BC1075B10E0BDA2E533A7367310A5722224D793599D97A3B715DAD919D856B960C4F9722DBAE91"
#define RSA_Q_1024          "E4B5BABDB58392D64C4D65819F5119574B15D28610140B200EA8F7A43F3818CC36A41F9818F0059ADA2F6A82BBB02CEB036E4966FCB3F8C6300D05ACE3756CED"
#define RSA_DP_1024         "BD3A053AB953D558015EC4AFD7C8A25B53FC135BB09BFF73F99C45AB68B11433762585F6DA524ED6AEEFDE6158A02D887497F76643BB0E72ECE9610E755E8E01"
#define RSA_DQ_1024         "868C6EE6CA513462441348432091DA61A3779C19687E122972D66E91BEEB66934515FACC44E777B4A8E53A38DCE80114E538CD8FFBDC78DF474771EE4B063AE5"
#define RSA_QP_1024         "615A691762362DFFE04C345CC60E8998B9A93D6D7DD110CCE69149F88E3261187E43889562E7A5628822948DE33EDFE1B6C4DB04AAF87D786F5CF9906A762C14"
#define RSA_N_C_1024        "7302B7A33C83618D3E49BF9B600D99DDF9600BF06FB8A59DC923E91244FE7E411581E3E8CCFC6651271D1EC0A135B0A63AEF5705F8AEC7D0D93DBE779176C1BA28F6E4C439395EF7D7A7FDC48A3D532CBDA75751BAC568A67560D65A585FB22663F3BA2BE2CDA97FF5E7D58171322FD41146B8FF8CAA9F1938E38795B75FBB5C"
#define RSA_P_C_1024        "1B79AE5A8692E52D05180A89A204684BC41AD57C9FA17270AEBBEA7C064D209A1A6208998695BEB236AD763FAC09153FDE4E74D20DED301D38D6707F732BA9A1"
#define RSA_Q_C_1024        "8F5F9FC2DB57FC68A2E6C1340C651DABF1A4DEBD04E5933B39644E8306A4D95BBA279DB8F40C5C479C3352D9A63D43811365EAB9473B78B2F9155D1EBD686218"
#define RSA_N_Q_1024        "E535F0EB"
#define RSA_P_Q_1024        "70FA2D8F"
#define RSA_Q_Q_1024        "CC562F1B"
#define CIPHER_1024         "1C655EE770256504CB35E425FCAA1CCDC827E75A1300AB3EFB81B5B96B5B16FCEA12D8B3FC8B430C1DB49E8ACCDE03CE211107E7FEF04B1C0E07AAF4D8A781A11A88815B9AB40E87A89D0DC917EBF00EBC1B2207F45A7725AE128F8262CD2D766281E425AC12F955E6817E492B69AACB1EC4897721F26A5AA8548B14CEF486A9"




// #define KEY_LEN_2048     2048 / 32
// #define RSA_N_2048           "75A18418B8EB30CD990303626314215772406FB53C90BC34F8963643CB7C86655174E82AC581EA9D93FBCD8B9B9623E9FE8AD5E2F9311C8FEEFB709D78CC961DC49A3CA5F55733E68A10563695782DE1C8BE5F031E84540E14AA369FA8E03D03CCC7E02B2A030C44AF4B989DBC99640BB4925B9C3AAE287C241C1AF133502AD61593C62FAB42604680FBE1EC77C98B68008C15E52C24035A8F220C1B944C547F1E0FA4C6475395839536FD286F23063E802D657C6D176B46E3B1862616D32EADB0DC1C1AF83EAF33640224658BB46052ACD8D8876A7F35A9232ED4AD2E15FD958F294A5BFFBA11E2E18F7D3377136F6C91B93C9656E289E19FE3E928FDF7FB7F"
// #define RSA_E_2048           "10001"
// #define RSA_D_2048           "562B23211914F0832B7B5197590CFDFF98EA2AEA909B55C357F67179E82E2825402E6B84297AA9EB14E47805B4CB9F33620B41F32AA8174C38BC681A72CB2B8C52E0C95CA9046038991AAE8CFDA133BB19DA9AAF2643B96F3724192F8BFDF7B438E692080C967EFE318B27192577181A9B043BA78E34D5E35A705C2C2472AD6D762273180C7DA3107658259BC5BF554B3CC2CF33F264DDB3C45406A047A1B3720A655CAFF677FA7DCFDB9F125A8C1D333E07F93C884AFC7E9444D6033AAB3975DED23BC71BCA3EC83CCF000D6586020B1BF483762BFE6F1C64CE021CB85AD538A18B7539D42619C6901364ED6B14D07EC9EFECA16AC59D5BAB0F8840A5D86281"
// #define RSA_P_2048           "9AA3212A0A6E3158E399844D2F44C9CC3D25D5DDF1C18B2F49E70BB2326F1E738C33DFB87A4DAC5EED914F72724C670D393D1B7368D2006DA1A649E5D03930C239F0A304C04F3222787436A271D544F8BD3DD3A3C2032B84C68B9080B600AE57395146C6F46C18DA1DB9129544D8B9C65F9DD624164A64AB500EB83AFDBDF279"
// #define RSA_Q_2048           "C2BC8CFDC7F5C23DE47E95D39BD0EE16B27957280655ED4F0D0C8793AACD279B374BA0C3CFF78781DA7D5EF8DE83FDDB83A04386E599FC5A20E113571852FBFE88275A684C3BF6A1F187E3497DD8EC6B7ACE419F471C615DA1FD48A36EF4DBC9CBC692A258BB67D6C213FD7D8FC513FE307E2A2943D7739227D7FD2EC4AB1FB7"
// #define RSA_DP_2048          "598E6E4F8DB8E1A56C32E5775A0FC99B1A32C6588281A79D1C7CCDBE470D29A29BA9134120BBC93F34F0FA04FB031A8F82FDCBDF1BEEBB46C2DEAE5F85270A01025345E62385FA301278A38792CB83E5569BEEED21187AE4ABA3FA6D407AC67D4779B5B6D5A9A0FEF945CCE85BF5F4295A08EC12FC41DB6987B4EEA7637AD569"
// #define RSA_DQ_2048          "9B8767BBD096317AA921889C271828EFABBF49A2C7DC9CD9C3FC3BD3EE5847C7A9D417240CD70F3CE0B9BCBE5B4963D88C39D574C9AFC062635C1FCC31BB2553D67E47B081226B0A50134DAE067AD7E7C77F2FDDFC37687415CA6AD74CE8F719264D0413F1764BAAB3FAAF3C37351990AC3E37821992DBD4E1499A065E40A5E5"
// #define RSA_QP_2048          "906598444A1664A4F3FD0E67DA92E0BCBB445101DC09ED567ACE2D49DBEC61B2E06ECD64544B0C35D26E68DBE3048B83A601285245AF4FFC94E3EF5F7602E3EC9B8AD6D9FBC518F95D3A638D7A3FC34E72307F67A48C0696753664D589BE2EC861EB659C7AB06C5A9095E4D8794D49504E651EAEE26C76091175C5B7082B4016"
// #define RSA_N_C_2048         "65B37280142A48FCED5C720FC0A17DB2A6B6C1901CD1FECA252FEB61E5CF58E4068800EE4F54D2D9E35566BC5CB976B497E65FFA529F398E562BB38AE891A03B212D88E98073DE85A5A00D9B2CA11D0B14AF22CD2C832FD8DCD5E4ADC6BA95FFC7FBEBC80FE9D32ACB4EB6F52C742B11F11D83655E30B5FC786E15CC8C8D1C9F9EF66284D337B8A697E4F8485064D28823FD0DB4E75F5618437D776D6910405AB88B467F2E5DD4C206C670807E25227E61D02EE32B37C731DA1DF141D36CC48B636867C37C6A08C17EE8416A0A33A0791EE2233C3915EC38B2DA1984DE95F00BEAA1575DBD1ACCF4F8DB37500656BE4CD7A874F6247A127C2F32A046197D4D2A"
// #define RSA_P_C_2048         "0224D929A1397374039926557BCA9FC74DD9E7AB3DBAF1A216DC1E57ED4F57B1A7D6E922F3CB5FE825FA14264BBFA864FD6129885EABC7C21680C2390511AC7189EF4F7F7BDEA690843353C18235E9E56BA985F712D44B377AE1578321A61DFAB7240E12597A5513B055E455BBAA66BCD25AAB72129D830B6EFAFFBBA5D30132"
// #define RSA_Q_C_2048         "5AD49E385E01DBA437ED91437ED4C9C17E1EE4F5EACABF9624C3C8AF4B4712D35900C84522FADC41D5723AA652D33F2F25DB60112F8DE2D9F907E8EE7B4A84129AA9FFCEF7FA1FFB4E4E879C5D55CFD45757AAC16739C495D5C756BFA4C3DEF9A591962919C298495A9727252B345D9470C4BFA33F5121AA861952B0D4A3A3D9"
// #define RSA_N_Q_2048         "FAEC3B81"
// #define RSA_P_Q_2048         "7D3E2837"
// #define RSA_Q_Q_2048         "552511F9"
// #define CIPHER_2048          "1A489B964931E96ECBED9DB0A357B0912C203B3020BA1427353AD06CAD229A77F9E864A11BF0AD6A4FE2CB88D3C0F4AE0B964C6122DA581E2E509D9B7828E41BDDC6A179F43EF2B1DAB09C4D49ACCE3CD55FBFA256E264189C365A2E8BE9640B98A73267E9A5ACBD9C93838AD76ED57DCD8C680F248CAC97CDA034CC348A5754EBFAAA3A855FF618CE6BCA51BCBAC33D105D0F6BF58FE1C0E7F8DF4CB293D48A4EC5FEA617DFA00F1E6688893FCF5DC7B45DE3C511E14DF2D6D072511664BF397D322DD61952882CE88E8F1D770B14340B52AAA2D2A388BF2A1F6A5D7A13EF149FF9AEDFE0A2657DCB9568A06FBFFB800D1CFB7CA625630D8DA39174008F93F9"



#define KEY_LEN_2048        2048 / 32
#define RSA_N_2048          "75A18418B8EB30CD990303626314215772406FB53C90BC34F8963643CB7C86655174E82AC581EA9D93FBCD8B9B9623E9FE8AD5E2F9311C8FEEFB709D78CC961DC49A3CA5F55733E68A10563695782DE1C8BE5F031E84540E14AA369FA8E03D03CCC7E02B2A030C44AF4B989DBC99640BB4925B9C3AAE287C241C1AF133502AD61593C62FAB42604680FBE1EC77C98B68008C15E52C24035A8F220C1B944C547F1E0FA4C6475395839536FD286F23063E802D657C6D176B46E3B1862616D32EADB0DC1C1AF83EAF33640224658BB46052ACD8D8876A7F35A9232ED4AD2E15FD958F294A5BFFBA11E2E18F7D3377136F6C91B93C9656E289E19FE3E928FDF7FB7F"
#define RSA_E_2048          "10001"
#define RSA_D_2048          "562B23211914F0832B7B5197590CFDFF98EA2AEA909B55C357F67179E82E2825402E6B84297AA9EB14E47805B4CB9F33620B41F32AA8174C38BC681A72CB2B8C52E0C95CA9046038991AAE8CFDA133BB19DA9AAF2643B96F3724192F8BFDF7B438E692080C967EFE318B27192577181A9B043BA78E34D5E35A705C2C2472AD6D762273180C7DA3107658259BC5BF554B3CC2CF33F264DDB3C45406A047A1B3720A655CAFF677FA7DCFDB9F125A8C1D333E07F93C884AFC7E9444D6033AAB3975DED23BC71BCA3EC83CCF000D6586020B1BF483762BFE6F1C64CE021CB85AD538A18B7539D42619C6901364ED6B14D07EC9EFECA16AC59D5BAB0F8840A5D86281"
#define RSA_P_2048          "9AA3212A0A6E3158E399844D2F44C9CC3D25D5DDF1C18B2F49E70BB2326F1E738C33DFB87A4DAC5EED914F72724C670D393D1B7368D2006DA1A649E5D03930C239F0A304C04F3222787436A271D544F8BD3DD3A3C2032B84C68B9080B600AE57395146C6F46C18DA1DB9129544D8B9C65F9DD624164A64AB500EB83AFDBDF279"
#define RSA_Q_2048          "C2BC8CFDC7F5C23DE47E95D39BD0EE16B27957280655ED4F0D0C8793AACD279B374BA0C3CFF78781DA7D5EF8DE83FDDB83A04386E599FC5A20E113571852FBFE88275A684C3BF6A1F187E3497DD8EC6B7ACE419F471C615DA1FD48A36EF4DBC9CBC692A258BB67D6C213FD7D8FC513FE307E2A2943D7739227D7FD2EC4AB1FB7"
#define RSA_DP_2048         "598E6E4F8DB8E1A56C32E5775A0FC99B1A32C6588281A79D1C7CCDBE470D29A29BA9134120BBC93F34F0FA04FB031A8F82FDCBDF1BEEBB46C2DEAE5F85270A01025345E62385FA301278A38792CB83E5569BEEED21187AE4ABA3FA6D407AC67D4779B5B6D5A9A0FEF945CCE85BF5F4295A08EC12FC41DB6987B4EEA7637AD569"
#define RSA_DQ_2048         "9B8767BBD096317AA921889C271828EFABBF49A2C7DC9CD9C3FC3BD3EE5847C7A9D417240CD70F3CE0B9BCBE5B4963D88C39D574C9AFC062635C1FCC31BB2553D67E47B081226B0A50134DAE067AD7E7C77F2FDDFC37687415CA6AD74CE8F719264D0413F1764BAAB3FAAF3C37351990AC3E37821992DBD4E1499A065E40A5E5"
#define RSA_QP_2048         "906598444A1664A4F3FD0E67DA92E0BCBB445101DC09ED567ACE2D49DBEC61B2E06ECD64544B0C35D26E68DBE3048B83A601285245AF4FFC94E3EF5F7602E3EC9B8AD6D9FBC518F95D3A638D7A3FC34E72307F67A48C0696753664D589BE2EC861EB659C7AB06C5A9095E4D8794D49504E651EAEE26C76091175C5B7082B4016"
#define RSA_N_C_2048            "65B37280142A48FCED5C720FC0A17DB2A6B6C1901CD1FECA252FEB61E5CF58E4068800EE4F54D2D9E35566BC5CB976B497E65FFA529F398E562BB38AE891A03B212D88E98073DE85A5A00D9B2CA11D0B14AF22CD2C832FD8DCD5E4ADC6BA95FFC7FBEBC80FE9D32ACB4EB6F52C742B11F11D83655E30B5FC786E15CC8C8D1C9F9EF66284D337B8A697E4F8485064D28823FD0DB4E75F5618437D776D6910405AB88B467F2E5DD4C206C670807E25227E61D02EE32B37C731DA1DF141D36CC48B636867C37C6A08C17EE8416A0A33A0791EE2233C3915EC38B2DA1984DE95F00BEAA1575DBD1ACCF4F8DB37500656BE4CD7A874F6247A127C2F32A046197D4D2A"
#define RSA_P_C_2048            "0224D929A1397374039926557BCA9FC74DD9E7AB3DBAF1A216DC1E57ED4F57B1A7D6E922F3CB5FE825FA14264BBFA864FD6129885EABC7C21680C2390511AC7189EF4F7F7BDEA690843353C18235E9E56BA985F712D44B377AE1578321A61DFAB7240E12597A5513B055E455BBAA66BCD25AAB72129D830B6EFAFFBBA5D30132"
#define RSA_Q_C_2048            "5AD49E385E01DBA437ED91437ED4C9C17E1EE4F5EACABF9624C3C8AF4B4712D35900C84522FADC41D5723AA652D33F2F25DB60112F8DE2D9F907E8EE7B4A84129AA9FFCEF7FA1FFB4E4E879C5D55CFD45757AAC16739C495D5C756BFA4C3DEF9A591962919C298495A9727252B345D9470C4BFA33F5121AA861952B0D4A3A3D9"
#define RSA_N_Q_2048            "FAEC3B81"
#define RSA_P_Q_2048            "7D3E2837"
#define RSA_Q_Q_2048            "552511F9"
#define CIPHER_2048         "1A489B964931E96ECBED9DB0A357B0912C203B3020BA1427353AD06CAD229A77F9E864A11BF0AD6A4FE2CB88D3C0F4AE0B964C6122DA581E2E509D9B7828E41BDDC6A179F43EF2B1DAB09C4D49ACCE3CD55FBFA256E264189C365A2E8BE9640B98A73267E9A5ACBD9C93838AD76ED57DCD8C680F248CAC97CDA034CC348A5754EBFAAA3A855FF618CE6BCA51BCBAC33D105D0F6BF58FE1C0E7F8DF4CB293D48A4EC5FEA617DFA00F1E6688893FCF5DC7B45DE3C511E14DF2D6D072511664BF397D322DD61952882CE88E8F1D770B14340B52AAA2D2A388BF2A1F6A5D7A13EF149FF9AEDFE0A2657DCB9568A06FBFFB800D1CFB7CA625630D8DA39174008F93F9"
#define PLAIN_2048          "0000AF087C93255BA8E6EA1A8153FA21092589A13CB69B6601000908547400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000AF087C93255BA8E6EA1A8153FA21092589A13CB69B660100090854740"



// #define KEY_LEN_2048         2048 / 32
// #define RSA_N_2048           "F5018171F5CAFC42042B9FE18BB552F172214D4B6C5200FE62174AA1E3D741FAB739A7524001FE6932909D0FD522CAE7D6767AA853338236CFAA9FC0564690008C86AD9858DA13E5786311365A2F0DDDA34186C351B0C8F63F45E0C2D2C957C20D6E6F9BB72AC760150BF4D478CCEE4F4DD3D73E86D4FBA5ED12B98135EB8BDB8E8350FEA75CE93BD17D20F879684E9E531AE9F215FBCD646DA10228BB897110ECAC0166184D0A323189508698A6FA7C5F5C023B672DE756AA287A85392227AF33EF2A5D5FABFF853235AC5E5163396A3E53175C6B3A10B848F01A1510A8871F13A02D17055C661334350E47E8C7A0FB16C14E712BDA2E72472FEC20C02DEB93"
// #define RSA_E_2048           "00010001"
// #define RSA_D_2048           "5B1087337B5F4A29A3712F88DEABB3BB8867365A8D5561872BA06A9E07988FAE8781C75E3BEA41CC89FDD452F92E686A897D1A140C70BDBA6FAF849731BA227601C5612A9A03DC97530AC770034F30012C5803A5FF6C0D15F1E8A024E9C1EA7B7710902D39848DFC79762B36F9FB79AC424A35DBC8B3CB211E1FF29143205CA7B181445D4C95B4E95AE75EB76D40AB6030D91E0B10722601F9755F147E5A1CB9DEF7E578A7AD1039DCD9BED7499CE67857C011AF19A0398A84064854756E747F5C1F63509354C5F8A6A47EFE69A3F6A85FA7473E4FDF1D84D8DA492FE2A4146E3D4DA3607F5D98C89AFD0299A6AB1948D1D80CAACA3BFE88C3B9D3EF835924A9"
// #define RSA_P_2048           "FAE4803F9E1DC7963040D113D018286081D15462C6134139D409251A80BD3E0DC6287AA3FE5EA53C12FD817132059B83C4D28CB1B1B2A6BBCE80E96B17CEA9C065AD95D5D1E2D77BD10E3913785039895339802C971FFAA57D2F5C90F013C3B8A51E653ED3CCF79183B03A2AFE38C268EF9F11CC79F598507298C50F6ADFCDA5"
// #define RSA_Q_2048           "F9FE53A81AE1A5010DB79791E3A10B6C3C47F22571F7A2648341C90C075642E1BBCAE99D6BF5E62FC09DDE0F29FD20D37B5F3FA213BCC6F089259A6278254DB7A5403AFA9007F7E0B8F2D8041A22648B9157A1072A8C59FC68273FCA24A35C3450992AE50F5478D5D4A788FEB02E3EF43C8037B7519622C054D7795D1D2D7ED7"
// #define RSA_DP_2048          "78E86B81BD123EDFFB0B117709DECA7E8FB13088954A2C31D12443143D9C756E2FE3CC0E82045C7ED1EC075864B1DD1B285C0B5F8AF23C75DF73B28960A4C09BAEA473C3E26CFE49761AF398956F9BFAB8F7C9F433343F174777EE950E8D87D1D1090FE3B23061D2677322E51B3481440ECE4AC68EB3B39E794B741414FE1BDD"
// #define RSA_DQ_2048          "208DA3AB2244FBCD9551B0E50875321D9803EE5E3DE6F7388B77078D0F6F862A0AE03367926564E216FCF7AB95D6266E238495AEAF4F47C08EBB5CCD31C3F9C8CE35FCF81FC549DBF3797BF39CCB99B82AE6F44B1099522672119A56E24A7B793C7D957E5A6EAF8578B990374A0DDB98C640140145187DD1F9BA4D4D78BD31E5"
// #define RSA_QP_2048          "CB210EA8AF586D320C872B1D65764829D9E03B9F154230451C2D56AD42B9E0465468AF70D8B44A7D321721ED447DEEDE681F549FB5316B7A1B27E8DC869C724F9B5AABDA0FB7C3A19FC629F73C9092969E4F68575832398C1FA01255B8364093DE5F6CD7F981D193EAD40FB2536C59AD18E1FE59A81ADFD389A2F1A534000993"
// #define CIPHER_2048          "4101F9EC1A7665F1C1D3BDA17AD3238CCAE9B8CB42EA73B0728A678797139DDEB62B5CA3BD882898D02E8E247EFA64E4AB2F05E2A8350B3E7FF3F2F7B3128D36182E49F462BF2FA50E1BA939F1E1EF70B95457AD610FB8A57DD96B6427732C0DA1CF212427D902C24B6B28B8F75FE6701A660C5862C77AD83D6C69F5CDD753869DD2FBFD76F4164AAD6EE97817680B8D6C5C1B5AC1059FC634552F065D52E5E3E7A458EEED1FF210BEB62C6BA2A0FE3D2CC1C3F5A8019B271F41FE36CA604BD209D2A71FAAC29EEA00085131768DE44BFE4FBC5B2747979F0653E57C4D82DA40579BDBA7391C6DA6754CFFC84F2B981C25880C75FC5BEB59BBE23FF3B70027DC"

// #define PLAIN                "303132333435363738394142434445463132333435363738"

// #define KEY_LEN_2048     2048 / 32
// #define RSA_N_2048           "835973F28DB780EEFC6D106E4C0478AFB92E3E8AA4992EB0ED27BE73DB3951ED603AA30361716FECC1540BB7852EC17A9FA54943397945E74590EE4550993237F45FE991DFC9765D01AF9CD3FE97997C03AD898AA63DB275FA10B1F874906BC0964C1DAA0892264DF001F5E180D30431A45280B4919727CC9164639A5905F198D89D7E534120B62AFA4C77C86BF90FEEA4E27DDA40438943A7FB0D46E9F986C5A5964208335AE5A8D31E8651B3FF569B55DFB231EBCC7A7C1C314C39F6B52627BE81359C12764F61BE429BABBF8F6355F65CAF7C26E98494CD346275E7C72A89F7E2A9231A535DE825E9FFCE5ED23ADF630A36DA4533FCE34E2EC88D49F18377"
// #define RSA_E_2048           "00010001"
// #define RSA_D_2048           "2A7EBF5F82F0129BBF393DEEA15375044D222403D0FAEA3B3D8EF5342081EBFAA37E750CFBF2AA666BA9D85C988F26F39840EE71FC5F3AF976ED4BD94B1935411B2408BA342FC6C6926C118E18B94D63ED00B1161570B2932EC34600FF1D566F297118CBD1180FA2797AF8E4EB3BDA0881845BB58FC0DA947999840C04AF42995A891C1EE63232E630E996199776C9C0D46EEBC5D5EBC47D11E8174F240FA4B02C8DB356B0747985CCB22959D21C1E9E415A33ABBF9CD0F5D3778AE48AA0041D7B1725DBC49927018D5B14A605444F8754B650D9687B9BB55F4EB3C99641C454AB0772D230D241F541C8297C6B5464BF8DCBC73F03F9754DCD12840F98B92A99"
// #define RSA_P_2048           "94F17261EE9B7D239DEDD72DA2E165ACFEC89D49DDE250E4053DB29180D1ADD386DA6617AF780E725984EC9C56B3A92ED8EFDD1AA0F3D96A6428B63C7FBE9DFCDE0D57E2292C16AD30D184A0976A0BBCC47B653E0739675A0A660837796DB72DF4C0DD3C3470AECE7B0D37B040BFA34D1AA4CF2CEB6A10AA4F2E42FA469615DB"
// #define RSA_Q_2048           "E1C2A40C3E360DCFE257C1DA8736A1B364BC9ADA60427389776DDBAA6B4EB117ADB994188DE4AD18A042BAA870A05DB86880A51300B4DC1A273D92C3F064E9D37F18215A3589656E1904D62B8710D7E91EC89ABDE57AEA34BF7F384D105CEBB7AF18E34B0DDE4DCAA5D5ADD9A63E273CDDCE0F52E74CB3CF966D66BFA3EDD195"
// #define RSA_DP_2048          "207E94AFDCF8BB527BF019D3F1072FC1904C80544F3E42DB9C711B76371E87C7F051D19835460210DC8AED7C26464810DA6F6A5396EDDC6F23AEE62348D3737069998BA4E1CAA69FDE58B790B9B7FF1B8DDA45FA446537B12337A36F46E4B2E429D3B1F0A2983AEAFD59A2DEA721A824F83D209DF2364FB07859E56EE8DB71A5"
// #define RSA_DQ_2048          "4636208AE6362D697FBD473ECD5A8243A68AB9A63CD5ADD50CDD8FB99A91E8A5B293CAA93047F4457A620667284FD795E87A49DC7515CA761FCA1880F39C8ED405ECDD428EEFE229B1823D915FFA2F0C0354E43B36C959597A4CF8978F053711F354CC2BA56E83C70878420F349293E56C1E0FC9FAC17212977802C28B1B0559"
// #define RSA_QP_2048          "430153EEC25E4CEA5442F7F1004BD430DC30074E6B9B6336B1E57B92CEF186F6BFA75009B705F8416E01B75AFA81C829F1B2637D2F8CA57815FF19A65FD956161034F187E80295709D0070EC5AE576449169E6FFA2EFCA2C1D0A5E76EA3B6DBEC11FF06711EF574A1AA3C35981AA350BD930CCBB4FAE8165648FB73D38CE27B6"
// #define CIPHER_2048          "5A17380BDD839D6A165F37FEC58A96CC0BAF0B26C2BDA45A29491A9D87FBEBF3321528313AE16DE8206E9E71A803836B32CB0821A5F9EA0E40C2527B21A9DC5C4DC3BC70D43ECE0D07703236723F3EBB49355DE09E9A6963EF2C9A42C991CE0E6AF555B9B01EDB681F8136689C8859759DD84FC91E616875913469AB4281AC038D8FFD9BF6682EAD4564360000659683FC543765C8EF5618207B8AD7C5E3893FE4A4C442933B9AD0D234AF1CF6F2F56A0712CBDDF211A4B1EF93567AAA84BDC96392259523DE33ADFE0A4A2CA833110E4CE1477E4BE88DEC48CDCCB1531C9B590F66A5F80DA1B36219797E95BBE72AD1956EC07A9F674300159B27CE4735D64E"

int bn_printf(const uint32_t *r, uint32_t len)
{
    char *s = NULL;
    uint32_t s_len;
    if(r == NULL || len == 0)
        return -1;
    //the X most significant bits number
    s_len = len;
    //radix is 16
    s_len = (s_len * 32) >> 2;
    s_len += 4;
    s = (char *)malloc(s_len);
    bn_write_string(s, &s_len, r, len);
    if(s_len <= 1)
        mh_printf("0");
    else
        mh_printf("%s", s);
    
    free(s);
    return 0;
}

static void rsa_read_key(mh_rsa_private_key* key, uint32_t key_size)
{
    if (key_size == 1024)
    {
        key->bytes = 1024 / 8;
        bn_read_string_to_bytes(key->n, key->bytes, RSA_N_1024);
        bn_read_string_to_bytes(key->e, 4, RSA_E_1024);
        bn_read_string_to_bytes(key->d, key->bytes, RSA_D_1024);
        bn_read_string_to_bytes(key->p, key->bytes/2, RSA_P_1024);
        bn_read_string_to_bytes(key->q, key->bytes/2, RSA_Q_1024);
        bn_read_string_to_bytes(key->dp, key->bytes/2, RSA_DP_1024);
        bn_read_string_to_bytes(key->dq, key->bytes/2, RSA_DQ_1024);
        bn_read_string_to_bytes(key->qp, key->bytes/2, RSA_QP_1024);
        bn_read_string_to_bytes(key->n_c, key->bytes, RSA_N_C_1024);
        bn_read_string_to_bytes(key->p_c, key->bytes/2, RSA_P_C_1024);
        bn_read_string_to_bytes(key->q_c, key->bytes/2, RSA_Q_C_1024);
        bn_read_string_to_bytes(key->n_q, 4, RSA_N_Q_1024);
        bn_read_string_to_bytes(key->p_q, 4, RSA_P_Q_1024);
        bn_read_string_to_bytes(key->q_q, 4, RSA_Q_Q_1024);
    }
    if (key_size == 2048)
    {
        key->bytes = 2048 / 8;
        bn_read_string_to_bytes(key->n, key->bytes, RSA_N_2048);
        bn_read_string_to_bytes(key->e, 4, RSA_E_2048);
        bn_read_string_to_bytes(key->d, key->bytes, RSA_D_2048);
        bn_read_string_to_bytes(key->p, key->bytes/2, RSA_P_2048);
        bn_read_string_to_bytes(key->q, key->bytes/2, RSA_Q_2048);
        bn_read_string_to_bytes(key->dp, key->bytes/2, RSA_DP_2048);
        bn_read_string_to_bytes(key->dq, key->bytes/2, RSA_DQ_2048);
        bn_read_string_to_bytes(key->qp, key->bytes/2, RSA_QP_2048);
        bn_read_string_to_bytes(key->n_c, key->bytes, RSA_N_C_2048);
        bn_read_string_to_bytes(key->p_c, key->bytes/2, RSA_P_C_2048);
        bn_read_string_to_bytes(key->q_c, key->bytes/2, RSA_Q_C_2048);
        bn_read_string_to_bytes(key->n_q, 4, RSA_N_Q_2048);
        bn_read_string_to_bytes(key->p_q, 4, RSA_P_Q_2048);
        bn_read_string_to_bytes(key->q_q, 4, RSA_Q_Q_2048);
    }
}


void RSA_Rand_Test(void);
void RSA_Fixed_Test(void);

void RSA_AutoRng_Test(void)
{
//	SHA_UpdateFixed_Test();
	
	RSA_Rand_Test();
	RSA_Fixed_Test();
}


void RSA_Rand_Test(void)
{
	
}

void RSA_Fixed_Test(void)
{
	
}

/**
 * 
 */

void rsa_func_test()
{
    uint32_t i, u32First;
    
    mh_rsa_private_key pri_key;
    mh_rsa_public_key pub_key;

    rsa_pub_key_t publickey;
    rsa_pri_key_t privatekey;
    
    uint8_t plain[2048 / 8];
    uint8_t cipher[2048 / 8];
    uint8_t tmp0[2048 / 8];
    uint32_t cipherlenth;
    uint32_t plainlenth;

    printf("\nrsa 1024 test\n");
    memset(&pri_key, 0, sizeof(pri_key));
    memset(&pub_key, 0, sizeof(pub_key));
    memset(&plain, 0, sizeof(plain));
    memset(&cipher, 0, sizeof(cipher));
    rsa_read_key(&pri_key, 1024);
    pub_key.bytes = pri_key.bytes;
    memcpy(pub_key.e, pri_key.e, sizeof(pri_key.e));
    memcpy(pub_key.n, pri_key.n, sizeof(pri_key.n));
    memcpy(pub_key.n_c, pri_key.n_c, sizeof(pri_key.n_c));
    memcpy(pub_key.n_q, pri_key.n_q, sizeof(pri_key.n_q));

    bn_read_string_to_bytes(plain, pri_key.bytes, PLAIN_1024);
    bn_read_string_to_bytes(cipher, pri_key.bytes, CIPHER_1024);

    mh_rsa_complete_key(&pri_key, NULL, NULL);

    memset(tmp0, 0, pri_key.bytes);
    memset(tmp0, 0, pri_key.bytes);
    //mh_rsa_private_crt(tmp0, cipher, &pri_key, NULL, NULL);
    mh_rsa_private(tmp0, cipher, &pri_key, NULL, NULL);
    r_printf((0 == memcmp(tmp0, plain, pri_key.bytes)), "mh_rsa_private test\n");

    
    memset(tmp0, 0, pri_key.bytes);
    mh_rsa_public(tmp0, plain, &pub_key, NULL, NULL);
    r_printf((0 == memcmp(tmp0, cipher, pri_key.bytes)), "mh_rsa_public test\n");

    
    //How to use rsa_public_func & rsa_private_func, this function doesn't need x_c x_q.
    publickey.bits = 1024;
    publickey.exponent = pri_key.e;
    publickey.modulus = pri_key.n;
    publickey.explen = 4;
    
    memset(cipher,0,128);
    cipherlenth = 128;
    rsa_public_func(cipher,&cipherlenth,plain,128,&publickey);
    //rsa_public_func_1(cipher, &cipherlenth, plain, 128, &publickey);
    ouputRes("rsa_public_func: cipher\n", cipher, 128);
    //Due to the different padding rule, we shouldn't compare the result with the function who use x_c x_q.
    
    privatekey.bits = 1024;
    privatekey.modulus = pri_key.n;
    privatekey.d = pri_key.d;
    privatekey.d_len = 128;
    
    memset(tmp0,0,128);
    plainlenth = 128;
    rsa_private_func(tmp0,&plainlenth,cipher,cipherlenth,&privatekey);
    //rsa_private_func_1(tmp0, &plainlenth, cipher, cipherlenth, &privatekey);
    ouputRes("rsa_private_func: plain\n", tmp0, plainlenth);
    
	//How to use rsa_public_func & rsa_private_func, this function doesn't need x_c x_q.
    publickey.bits = 1024;
    publickey.exponent = pri_key.e;
    publickey.modulus = pri_key.n;
    publickey.explen = 4;
    
    memset(cipher,0,128);
    cipherlenth = 128;
    rsa_public_func_1(cipher,&cipherlenth,plain,128,&publickey);
    //rsa_public_func_1(cipher, &cipherlenth, plain, 128, &publickey);
    ouputRes("rsa_public_func_1: cipher\n", cipher, 128);
    //Due to the different padding rule, we shouldn't compare the result with the function who use x_c x_q.
    
    privatekey.bits = 1024;
    privatekey.modulus = pri_key.n;
    privatekey.d = pri_key.d;
    privatekey.d_len = 128;
    
    memset(tmp0,0,128);
    plainlenth = 128;
    rsa_private_func_1(tmp0,&plainlenth,cipher,cipherlenth,&privatekey);
    //rsa_private_func_1(tmp0, &plainlenth, cipher, cipherlenth, &privatekey);
    ouputRes("rsa_private_func_1: plain\n", tmp0, plainlenth);
	
	
	r_printf((0 == memcmp(tmp0, plain, plainlenth)), "mh_rsa_public test\n");
//    //rsa_public_func&rsa_private_func will delete preamble zero.
//    for (i = 0; i < 128; i++)
//    {
//        if (0 != plain[i])
//        {
//            break;
//        }
//    }

//    r_printf((0 == memcmp(tmp0, plain + i, plainlenth)), "mh_rsa_public test\n");
}


void rsa_func_test_2048()
{
    uint32_t i, u32First;
	
    mh_rng_callback f_rng = mh_rand_p;
	
    mh_rsa_private_key pri_key;
    mh_rsa_public_key pub_key;

    rsa_pub_key_t publickey;
    rsa_pri_key_t privatekey;
    
    uint8_t plain[2048 / 8];
    uint8_t cipher[2048 / 8];
    uint8_t tmp0[2048 / 8];
    uint32_t cipherlenth;
    uint32_t plainlenth;

    printf("\nrsa 2048 test\n");
    memset(&pri_key, 0, sizeof(pri_key));
    memset(&pub_key, 0, sizeof(pub_key));
    memset(&plain, 0, sizeof(plain));
    memset(&cipher, 0, sizeof(cipher));
    rsa_read_key(&pri_key, 2048);
    pub_key.bytes = pri_key.bytes;
    memcpy(pub_key.e, pri_key.e, sizeof(pri_key.e));
    memcpy(pub_key.n, pri_key.n, sizeof(pri_key.n));
    memcpy(pub_key.n_c, pri_key.n_c, sizeof(pri_key.n_c));
    memcpy(pub_key.n_q, pri_key.n_q, sizeof(pri_key.n_q));

    bn_read_string_to_bytes(plain, pri_key.bytes, PLAIN_2048);
    bn_read_string_to_bytes(cipher, pri_key.bytes, CIPHER_2048);

    mh_rsa_complete_key(&pri_key, f_rng, NULL);

    memset(tmp0, 0, pri_key.bytes);
//    memset(tmp0, 0, pri_key.bytes);
//    //mh_rsa_private_crt(tmp0, cipher, &pri_key, NULL, NULL);
//    mh_rsa_private(tmp0, cipher, &pri_key, f_rng, NULL);
//    r_printf((0 == memcmp(tmp0, plain, pri_key.bytes)), "mh_rsa_private test\n");

//    
//    memset(tmp0, 0, pri_key.bytes);
//    mh_rsa_public(tmp0, plain, &pub_key, f_rng, NULL);
//    r_printf((0 == memcmp(tmp0, cipher, pri_key.bytes)), "mh_rsa_public test\n");

    
//    //How to use rsa_public_func & rsa_private_func, this function doesn't need x_c x_q.
//    publickey.bits = 2048;
//    publickey.exponent = pri_key.e;
//    publickey.modulus = pri_key.n;
//    publickey.explen = 4;
//    
//    memset(cipher,0,256);
//    cipherlenth = 256;
//    rsa_public_func(cipher,&cipherlenth,plain,256,&publickey);
//    //rsa_public_func_1(cipher, &cipherlenth, plain, 128, &publickey);
//    ouputRes("rsa_public_func: cipher\n", cipher, 256);
//    //Due to the different padding rule, we shouldn't compare the result with the function who use x_c x_q.
//    
//    privatekey.bits = 2048;
//    privatekey.modulus = pri_key.n;
//    privatekey.d = pri_key.d;
//    privatekey.d_len = 256;
//    
//    memset(tmp0,0,256);
//    plainlenth = 5;
//    rsa_private_func(tmp0,&plainlenth,cipher,cipherlenth,&privatekey);
//    //rsa_private_func_1(tmp0, &plainlenth, cipher, cipherlenth, &privatekey);
//    ouputRes("rsa_private_func: plain\n", tmp0, plainlenth);
    
	//How to use rsa_public_func & rsa_private_func, this function doesn't need x_c x_q.
    publickey.bits = 2048;
    publickey.exponent = pri_key.e;
    publickey.modulus = pri_key.n;
    publickey.explen = 4;
    
    memset(cipher,0,256);
    cipherlenth = 256;
    rsa_public_func_1(cipher,&cipherlenth,plain,256,&publickey);
    //rsa_public_func_1(cipher, &cipherlenth, plain, 128, &publickey);
    ouputRes("rsa_public_func_1: cipher\n", cipher, 256);
    //Due to the different padding rule, we shouldn't compare the result with the function who use x_c x_q.
    
    privatekey.bits = 2048;
    privatekey.modulus = pri_key.n;
    privatekey.d = pri_key.d;
    privatekey.d_len = 256;
    
    memset(tmp0,0,256);
    plainlenth = 256;
    rsa_private_func_1(tmp0,&plainlenth,cipher,cipherlenth,&privatekey);
    //rsa_private_func_1(tmp0, &plainlenth, cipher, cipherlenth, &privatekey);
    ouputRes("rsa_private_func_1: plain\n", tmp0, 256);
	
	
	r_printf((0 == memcmp(tmp0, plain, plainlenth)), "mh_rsa_public test\n");
//    //rsa_public_func&rsa_private_func will delete preamble zero.
//    for (i = 0; i < 128; i++)
//    {
//        if (0 != plain[i])
//        {
//            break;
//        }
//    }

//    r_printf((0 == memcmp(tmp0, plain + i, plainlenth)), "mh_rsa_public test\n");
}


int key_lenth = 0;
void rsa_self_test(void)
{
    mh_rsa_private_key pri_key;
    mh_rsa_public_key pub_key;

    uint8_t plain[2048 / 8];
    uint8_t cipher[2048 / 8];
    uint8_t tmp0[2048 / 8];
    uint32_t u32Len = 2048 / 8;
    
    rsa_pri_key_t privatekey;
    
    //////////////////////////////////1024//////////////////////////////
    
    DBG_PRINT("\nrsa 1024 test\n");

    memset(&pri_key, 0, sizeof(pri_key));
    memset(&pub_key, 0, sizeof(pub_key));
    memset(&plain, 0, sizeof(plain));
    memset(&cipher, 0, sizeof(cipher));

    rsa_read_key(&pri_key, 1024);
    
    memset(pri_key.e, 0, sizeof(pri_key.e));
    memset(pri_key.n, 0, sizeof(pri_key.n));
    memset(pri_key.dp, 0, sizeof(pri_key.dp));
    memset(pri_key.dq, 0, sizeof(pri_key.dq));
    memset(pri_key.qp, 0, sizeof(pri_key.qp));
    memset(pri_key.n_c, 0, sizeof(pri_key.n_c));
    memset(pri_key.n_q, 0, sizeof(pri_key.n_q));
    memset(pri_key.p_c, 0, sizeof(pri_key.p_c));
    memset(pri_key.p_q, 0, sizeof(pri_key.p_q));
    memset(pri_key.q_c, 0, sizeof(pri_key.q_c));
    memset(pri_key.q_q, 0, sizeof(pri_key.q_q));
    
    mh_rsa_complete_key(&pri_key, mh_rand_p, NULL);
    ouputRes("n_c\n", pri_key.n_c, sizeof(pri_key.n_c));
    ouputRes("n_q\n", pri_key.n_q, sizeof(pri_key.n_q));
    ouputRes("p_c\n", pri_key.p_c, sizeof(pri_key.p_c));
    ouputRes("p_q\n", pri_key.p_q, sizeof(pri_key.p_q));
    ouputRes("q_c\n", pri_key.q_c, sizeof(pri_key.q_c));
    ouputRes("q_q\n", pri_key.q_q, sizeof(pri_key.q_q));
    

    bn_read_string_to_bytes(plain, pri_key.bytes, PLAIN_1024);
    bn_read_string_to_bytes(cipher, pri_key.bytes, CIPHER_1024);

    memset(tmp0, 0, pri_key.bytes);
    mh_rsa_private(tmp0, cipher, &pri_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, plain, pri_key.bytes)), "mh_rsa_private test\n");

    //How to get n_c & n_q(pub key and pri key use the same method)
    u32Len = pri_key.bytes;
    memset(pri_key.n_c, 0, sizeof(pri_key.n_c));
    memset(pri_key.n_q, 0, sizeof(pri_key.n_q));
    memswap(tmp0, sizeof(tmp0), pri_key.n, u32Len);
    bn_get_C((uint32_t *)plain, (uint32_t *)tmp0, u32Len >> 2);
    memswap(pri_key.n_c, u32Len, plain, pri_key.bytes);
    bn_get_Q((uint32_t *)plain, (uint32_t *)tmp0);
    memswap(pri_key.n_q, sizeof(pri_key.n_q), plain, u32Len);
    ouputRes("n_c_new\n", pri_key.n_c, sizeof(pri_key.n_c));
    ouputRes("n_q_new\n", pri_key.n_q, sizeof(pri_key.n_q));
    
    u32Len = pri_key.bytes >> 1;
    memset(pri_key.p_c, 0, sizeof(pri_key.p_c));
    memset(pri_key.p_q, 0, sizeof(pri_key.p_q));
    memswap(tmp0, sizeof(tmp0), pri_key.p, u32Len);
    bn_s_get_C((uint32_t *)plain, (uint32_t *)tmp0, u32Len >> 2, mh_rand_p, NULL);
    memswap(pri_key.p_c, u32Len, plain, u32Len);
    bn_s_get_Q((uint32_t *)plain, (uint32_t *)tmp0, mh_rand_p, NULL);
    memswap(pri_key.p_q, sizeof(pri_key.p_q), plain, u32Len);
    ouputRes("p_c\n", pri_key.p_c, sizeof(pri_key.p_c));
    ouputRes("p_q\n", pri_key.p_q, sizeof(pri_key.p_q));

    u32Len = pri_key.bytes >> 1;
    memset(pri_key.q_c, 0, sizeof(pri_key.q_c));
    memset(pri_key.q_q, 0, sizeof(pri_key.q_q));
    memswap(tmp0, sizeof(tmp0), pri_key.q, u32Len);
    bn_s_get_C((uint32_t *)plain, (uint32_t *)tmp0, u32Len >> 2, mh_rand_p, NULL);
    memswap(pri_key.q_c, u32Len, plain, u32Len);
    bn_s_get_Q((uint32_t *)plain, (uint32_t *)tmp0, mh_rand_p, NULL);
    memswap(pri_key.q_q, sizeof(pri_key.q_q), plain, u32Len);
    ouputRes("q_c\n", pri_key.q_c, sizeof(pri_key.q_c));
    ouputRes("q_q\n", pri_key.q_q, sizeof(pri_key.q_q));
    
    
    pub_key.bytes = pri_key.bytes;
    memcpy(pub_key.e, pri_key.e, sizeof(pri_key.e));
    memcpy(pub_key.n, pri_key.n, sizeof(pri_key.n));
    memcpy(pub_key.n_c, pri_key.n_c, sizeof(pri_key.n_c));
    memcpy(pub_key.n_q, pri_key.n_q, sizeof(pri_key.n_q));
    
    bn_read_string_to_bytes(plain, pri_key.bytes, PLAIN_1024);
    memset(tmp0, 0, pri_key.bytes);
    mh_rsa_public(tmp0, plain, &pub_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, cipher, pri_key.bytes)), "mh_rsa_public test\n");
    
    memset(tmp0, 0, pri_key.bytes);
    mh_rsa_private_crt(tmp0, cipher, &pri_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, plain, pri_key.bytes)), "mh_rsa_private_crt test\n");
    
    
    
    //////////////////////////////////2048//////////////////////////////
    
    DBG_PRINT("\nrsa 2048 test\n");

    rsa_read_key(&pri_key, 2048);
    
    mh_rsa_complete_key(&pri_key, mh_rand_p, NULL);
    
    pub_key.bytes = pri_key.bytes;
    memcpy(pub_key.e, pri_key.e, sizeof(pri_key.e));
    memcpy(pub_key.n, pri_key.n, sizeof(pri_key.n));
    memcpy(pub_key.n_c, pri_key.n_c, sizeof(pri_key.n_c));
    memcpy(pub_key.n_q, pri_key.n_q, sizeof(pri_key.n_q));

    bn_read_string_to_bytes(plain, pri_key.bytes, PLAIN);
    bn_read_string_to_bytes(cipher, pri_key.bytes, CIPHER_2048);

    memset(tmp0, 0, pri_key.bytes);
    mh_rsa_private(tmp0, cipher, &pri_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, plain, pri_key.bytes)), "mh_rsa_private test\n");

    
    memset(tmp0, 0, pri_key.bytes);
//	memset(pri_key.n, 0, sizeof(pri_key.n));
//	memset(pri_key.d, 0, sizeof(pri_key.d));
    mh_rsa_private_crt(tmp0, cipher, &pri_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, plain, pri_key.bytes)), "mh_rsa_private_crt test\n");
    
    memset(tmp0, 0, pri_key.bytes);
    mh_rsa_public(tmp0, plain, &pub_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, cipher, pri_key.bytes)), "mh_rsa_public test\n");
    DBG_PRINT("\n");
}


void rsa_gen_key_self_test(void)
{
    mh_rsa_private_key key;
    DBG_PRINT("RSA Gen start!\n");
    mh_rsa_gen_key(&key, 0x10001, 2048, NULL, NULL);
    mh_rsa_efc_gen_key(&key, 0x10001, 2048, mh_rand_p, NULL);
    DBG_PRINT("RSA Gen end!\n");
}

void rsa_complete_key_self_test(void)
{
    mh_rsa_private_key key1, key2;
    mh_rsa_public_key key3, key4;
    memset(&key1, 0, sizeof(key1));
    memset(&key2, 0, sizeof(key2));
    rsa_read_key(&key1, 1024);
    rsa_read_key(&key2, 1024);
    key4.bytes = key1.bytes;
    key3.bytes = key1.bytes;
    memcpy(key4.e, key2.e, sizeof(key2.e));
    memcpy(key4.n, key2.n, sizeof(key2.n));
    memcpy(key4.n_c, key2.n_c, sizeof(key2.n_c));
    memcpy(key4.n_q, key2.n_q, sizeof(key2.n_q));
    memcpy(key3.e, key2.e, sizeof(key2.e));
    memcpy(key3.n, key2.n, sizeof(key2.n));
    memset(key3.n_c, 0, sizeof(key3.n_c));
    memset(key3.n_q, 0, sizeof(key3.n_q));

//    memset(key1.e, 0, sizeof(key1.e));
    memset(key1.n, 0, sizeof(key1.n));
    memset(key1.dp, 0, sizeof(key1.dp));
    memset(key1.dq, 0, sizeof(key1.dq));
    memset(key1.qp, 0, sizeof(key1.qp));
    memset(key1.n_c, 0, sizeof(key1.n_c));
    memset(key1.n_q, 0, sizeof(key1.n_q));
    memset(key1.p_c, 0, sizeof(key1.p_c));
    memset(key1.p_q, 0, sizeof(key1.p_q));
    memset(key1.q_c, 0, sizeof(key1.q_c));
    memset(key1.q_q, 0, sizeof(key1.q_q));

    mh_rsa_complete_key(&key1, mh_rand_p, NULL);
    r_printf(0 == memcmp(&key2, &key1, sizeof(mh_rsa_private_key)), "rsa key complete test\n");

//    memset(key1.d, 0, sizeof(key1.d));
    memset(key1.n, 0, sizeof(key1.n));
    memset(key1.dp, 0, sizeof(key1.dp));
    memset(key1.dq, 0, sizeof(key1.dq));
    memset(key1.qp, 0, sizeof(key1.qp));
    memset(key1.n_c, 0, sizeof(key1.n_c));
    memset(key1.n_q, 0, sizeof(key1.n_q));
    memset(key1.p_c, 0, sizeof(key1.p_c));
    memset(key1.p_q, 0, sizeof(key1.p_q));
    memset(key1.q_c, 0, sizeof(key1.q_c));
    memset(key1.q_q, 0, sizeof(key1.q_q));
    mh_rsa_complete_key_e(&key1, mh_rand_p, NULL);
    r_printf(0 == memcmp(&key2, &key1, sizeof(mh_rsa_private_key)), "rsa key complete e test\n");


    memset(key1.n_c, 0, sizeof(key1.n_c));
    memset(key1.n_q, 0, sizeof(key1.n_q));
    memset(key1.p_c, 0, sizeof(key1.p_c));
    memset(key1.p_q, 0, sizeof(key1.p_q));
    memset(key1.q_c, 0, sizeof(key1.q_c));
    memset(key1.q_q, 0, sizeof(key1.q_q));
    mh_rsa_get_private_key_C_Q(&key1, mh_rand_p, NULL);
    r_printf(0 == memcmp(&key2, &key1, sizeof(mh_rsa_private_key)), "rsa key private get cq test\n");


    memset(key3.n_c, 0, sizeof(key3.n_c));
    memset(key3.n_q, 0, sizeof(key3.n_q));
    mh_rsa_get_public_key_C_Q(&key3, mh_rand_p, NULL);
    r_printf(0 == memcmp(&key4, &key3, sizeof(mh_rsa_public_key)), "rsa key public get cq test\n");
    DBG_PRINT("\n");
}


void mh_rsa_printf_bn(uint32_t *bn, uint32_t len)
{
    uint32_t i;
    for (i = 0; i < len; i++)
    {
        DBG_PRINT("0x%08X, ", bn[i]);
        if (7 == i%8)
            DBG_PRINT("\n");
    }
    DBG_PRINT("\n");
}


void mh_rsa_gen_efc_para_test(void)
{
    mh_rsa_efc_para_def efc;
    uint32_t qmin_192[6] = {0x3, 0, 0, 0, 0, 0xC0000000};
    uint32_t qmax_192[6] = {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
    
    uint32_t qmin_256[8] = {0x3, 0, 0, 0, 0, 0, 0, 0xC0000000};
    uint32_t qmax_256[8] = {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
            
    
    uint32_t qmin_512[16] = {0x3, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0xC0000000};
    uint32_t qmax_512[16] = {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
                        0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
    
    uint32_t qmin_1024[32] = {0x3, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0xC0000000};
    uint32_t qmax_1024[32] = {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
                        0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
                        0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
                        0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};

    memset(&efc, 0, sizeof(efc));
    mh_rsa_gen_efc_para(&efc, qmin_1024, qmax_1024, bn_size(qmin_1024));

    DBG_PRINT("ecf eta:\n");bn_printf(efc.eta, bn_size(qmin_1024));DBG_PRINT("\n");
    DBG_PRINT("ecf ro:\n");bn_printf(efc.ro, bn_size(qmin_1024));DBG_PRINT("\n");
    DBG_PRINT("ecf pi:\n");bn_printf(efc.pi, bn_size(qmin_1024));DBG_PRINT("\n");
    
    mh_rsa_printf_bn(efc.eta, bn_size(qmin_1024));
    mh_rsa_printf_bn(efc.ro, bn_size(qmin_1024));
    mh_rsa_printf_bn(efc.pi, bn_size(qmin_1024));


    memset(&efc, 0, sizeof(efc));
    mh_rsa_gen_efc_para(&efc, qmin_512, qmax_512, bn_size(qmin_512));

    DBG_PRINT("ecf eta:\n");bn_printf(efc.eta, bn_size(qmin_512));DBG_PRINT("\n");
    DBG_PRINT("ecf ro:\n");bn_printf(efc.ro, bn_size(qmin_512));DBG_PRINT("\n");
    DBG_PRINT("ecf pi:\n");bn_printf(efc.pi, bn_size(qmin_512));DBG_PRINT("\n");

    mh_rsa_printf_bn(efc.eta, bn_size(qmin_512));
    mh_rsa_printf_bn(efc.ro, bn_size(qmin_512));
    mh_rsa_printf_bn(efc.pi, bn_size(qmin_512));
    
    
    memset(&efc, 0, sizeof(efc));
    mh_rsa_gen_efc_para(&efc, qmin_256, qmax_256, bn_size(qmin_256));

    DBG_PRINT("ecf eta:\n");bn_printf(efc.eta, bn_size(qmin_256));DBG_PRINT("\n");
    DBG_PRINT("ecf ro:\n");bn_printf(efc.ro, bn_size(qmin_256));DBG_PRINT("\n");
    DBG_PRINT("ecf pi:\n");bn_printf(efc.pi, bn_size(qmin_256));DBG_PRINT("\n");

    mh_rsa_printf_bn(efc.eta, bn_size(qmin_256));
    mh_rsa_printf_bn(efc.ro, bn_size(qmin_256));
    mh_rsa_printf_bn(efc.pi, bn_size(qmin_256));
    
    
    memset(&efc, 0, sizeof(efc));
    mh_rsa_gen_efc_para(&efc, qmin_192, qmax_192, bn_size(qmin_192));

    DBG_PRINT("ecf eta:\n");bn_printf(efc.eta, bn_size(qmin_192));DBG_PRINT("\n");
    DBG_PRINT("ecf ro:\n");bn_printf(efc.ro, bn_size(qmin_192));DBG_PRINT("\n");
    DBG_PRINT("ecf pi:\n");bn_printf(efc.pi, bn_size(qmin_192));DBG_PRINT("\n");

    mh_rsa_printf_bn(efc.eta, bn_size(qmin_192));
    mh_rsa_printf_bn(efc.ro, bn_size(qmin_192));
    mh_rsa_printf_bn(efc.pi, bn_size(qmin_192));
    
}

void mh_rsa_efc_gen_prime_test(void)
{
    uint32_t p[32];
    
    while(1)
    {
        memset(p, 0, sizeof(p));
        mh_rsa_efc_gen_prime(p, 512, mh_rand_p, NULL);
        DBG_PRINT("prime:\n");bn_printf(p, bn_size(p));DBG_PRINT("\n");
    }
}


#if 0
void mh_rsa_gen_key_time_test2(void)
{
    uint32_t i, j, k;
    mh_rsa_private_key key;
    uint32_t count = 1000;
    uint32_t time[2][2], time_max[2][2] = {0}, time_min[2][2] = {0}, t = 0;
    uint32_t (*gen_key[2])(mh_rsa_private_key *, uint32_t e, uint32_t bits);
    uint32_t key_bits[2] = {2048, 1024};
    unsigned char s[][20] = {"mh_rsa_gen_key", "mh_rsa_efc_gen_key"};

    gen_key[0] = mh_rsa_gen_key;
    gen_key[1] = mh_rsa_efc_gen_key;

    timer_init();
    
    //2048 or 1024
    for(i = 0; i < 2; i++)
    {
        //mh_rsa_gen_key or mh_rsa_efc_gen_key
        for(j = 0; j < 2; j++)
        {
            time[i][j] = 0;
            time_max[i][j] = 0;
            time[i][j] = 0;
            for(k = 0; k < count; k++)
            {
                timer_start(0);
                gen_key[j](&key, 0x10001, key_bits[i]);
                t = timer_tick(0);
                time[i][j] += t;
                if(t > time_max[i][j])
                    time_max[i][j] = t;
                if(time_min[i][j] == 0 || time_min[i][j] > t)
                    time_min[i][j] = t;
                printf("times: %d useing time: %dms\n", k, t * 100);
            }
            printf("%s %d %dtimes average time: %dms\n",s[j], key_bits[i], k, time[i][j] * 100 / count);
            printf("%s %d %dtimes maxmum  time: %dms\n",s[j], key_bits[i], k, time_max[i][j] * 100);
            printf("%s %d %dtimes minmum  time: %dms\n",s[j], key_bits[i], k, time_min[i][j] * 100);
        }
    }
}


void rsa_stack_test(void)
{
    mh_rsa_private_key pri_key;
    mh_rsa_public_key pub_key;

    uint8_t plain[2048 / 8];
    uint8_t cipher[2048 / 8];
    uint8_t tmp0[2048 / 8];
    uint32_t u32Len = 2048 / 8;
    
    rsa_pri_key_t privatekey;
    
    //////////////////////////////////1024//////////////////////////////
    
    DBG_PRINT("\nrsa 1024 test\n");

    //mh_rsa_gen_key(&pri_key, 0x10001, 2048, mh_rand_p, NULL);
    memset(&pri_key, 0, sizeof(pri_key));
    memset(&pub_key, 0, sizeof(pub_key));
    memset(&plain, 0, sizeof(plain));
    memset(&cipher, 0, sizeof(cipher));

    rsa_read_key(&pri_key, 1024);
    
    //mh_rsa_complete_key(&pri_key, mh_rand_p, NULL);
    
  
    ouputRes("n_c\n", pri_key.n_c, sizeof(pri_key.n_c));
    ouputRes("n_q\n", pri_key.n_q, sizeof(pri_key.n_q));
    ouputRes("p_c\n", pri_key.p_c, sizeof(pri_key.p_c));
    ouputRes("p_q\n", pri_key.p_q, sizeof(pri_key.p_q));
    ouputRes("q_c\n", pri_key.q_c, sizeof(pri_key.q_c));
    ouputRes("q_q\n", pri_key.q_q, sizeof(pri_key.q_q));
    
    pub_key.bytes = pri_key.bytes;
    memcpy(pub_key.e, pri_key.e, sizeof(pri_key.e));
    memcpy(pub_key.n, pri_key.n, sizeof(pri_key.n));
    memcpy(pub_key.n_c, pri_key.n_c, sizeof(pri_key.n_c));
    memcpy(pub_key.n_q, pri_key.n_q, sizeof(pri_key.n_q));

    bn_read_string_to_bytes(plain, pri_key.bytes, PLAIN_1024);
    bn_read_string_to_bytes(cipher, pri_key.bytes, CIPHER_1024);

    memset(tmp0, 0, pri_key.bytes);
    mh_rsa_private(tmp0, cipher, &pri_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, plain, pri_key.bytes)), "mh_rsa_private test\n");

    
    memset(tmp0, 0, pri_key.bytes);
    mh_rsa_public(tmp0, plain, &pub_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, cipher, pri_key.bytes)), "mh_rsa_public test\n");
    
    memset(tmp0, 0, pri_key.bytes);
    mh_rsa_private_crt(tmp0, cipher, &pri_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, plain, pri_key.bytes)), "mh_rsa_private_crt test\n");
    
    
    
    //////////////////////////////////2048//////////////////////////////
    
    DBG_PRINT("\nrsa 2048 test\n");

    rsa_read_key(&pri_key, 2048);
    
    mh_rsa_complete_key(&pri_key, mh_rand_p, NULL);
    
    pub_key.bytes = pri_key.bytes;
    memcpy(pub_key.e, pri_key.e, sizeof(pri_key.e));
    memcpy(pub_key.n, pri_key.n, sizeof(pri_key.n));
    memcpy(pub_key.n_c, pri_key.n_c, sizeof(pri_key.n_c));
    memcpy(pub_key.n_q, pri_key.n_q, sizeof(pri_key.n_q));

    bn_read_string_to_bytes(plain, pri_key.bytes, PLAIN);
    bn_read_string_to_bytes(cipher, pri_key.bytes, CIPHER_2048);

    memset(tmp0, 0, pri_key.bytes);
    mh_rsa_private(tmp0, cipher, &pri_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, plain, pri_key.bytes)), "mh_rsa_private test\n");

    
    memset(tmp0, 0, pri_key.bytes);
    mh_rsa_private_crt(tmp0, cipher, &pri_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, plain, pri_key.bytes)), "mh_rsa_private_crt test\n");
    
    memset(tmp0, 0, pri_key.bytes);
    mh_rsa_public(tmp0, plain, &pub_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, cipher, pri_key.bytes)), "mh_rsa_public test\n");
    DBG_PRINT("\n");

}



#define INPUT   "931FA96F12B5015F85D5CB0C6ABA67C389AB2DA9F41AB7AC9F8A9C3EF60C161C522AB4F541ED95D44D6B1C3C3A650819B002BC69B1F2FCE2FB2E30ABB7862D8B9DB65AE298991C723B6A51473C6818A10D57DC9CD48A8B67761BF5255402EC63C92CE4D5E7F9B1B9F32421E6DADAFDB271E84298EE3781886ABDD3105B6215B50729EEFDB450D3558E44016715963E70DEA2298DC638DC24BBB80DEA3C2721629020E97E5CBA61BDBDFE28ED0512E03DC54F3218CC1F7BA78D317AE830B2CD4404154AFDBCFE9EE5D1772743551B82B3D0E5C936B87AE744260D59FFF24566325DE69E2F2BB0555C267FB4B62BFC90772F58351ED4B08B"
#define N_1     "97CF8BAD30CAE0F9A89285454DDDE967AAFBCD4BC0B78F29ECB1005286F15F6D7532A9C476607C73FF7424316DFC741894AA52EDBAF909719C7B53448343B45CF2F00A8ABFB78CEEBE848933AAED97DBE84F0730F34FB1AA1528D3D6EC75B73252A30D0C717518BE36458ADD0FBF854C65497F3F54084154B60F51561361EE8E85F742A54005524CB00FEBC334276E0E63DAD86C079A9A3DF5DD32BECADE1AB2B71F5F0A0E95A4000D01F1044A578AAD92E9FDE92E3C6AA3DCD4913DFA5552537E7DE75E241FAED455D76CB8FCAFEED3FD6DAB24D7A9C32852F866C751D7710F494A0DF11B67FAECDD87A9A4E2CC44F6F27E46E3C0CCCD0F"
#define N_2     "BFD0AA2AA8F44A94E24787A377776EE08E2A68BB4F297C3494F4ADD391C2567678A8B5E7CAC17CE35D5918F82F995C149DA6808E07ACC65A85795301907F5909437F53B014900EA5B5574631F183EC1423AFCD9C21FD13D3747A899FFDA7F8BBCBC7C07808D54D71B545556C2602518BB8A7811FA23A7835D8986B720484A20129DF4AFC2738B1C1DC2E0F98D0C99EC8FECB9FA6A2F50674BA9E7CA7FFFA49AC868EF6F483ECC51BEDC2F3B5EDF759212F99E025474C56D964F2F97BC1843F9D735E1F4EB1892C629D21491AC555A9FC2F755FDAA3DF7CA02BBAEFE0C0647915DC827D48F67ABD3AE33C3E95704F010291D53410CCEE81"




void rsa_stack_test1(void)
{
    mh_rsa_private_key pri_key;
    mh_rsa_public_key pub_key;

    uint8_t plain[2048 / 8];
    uint8_t cipher[2048 / 8];
    uint8_t tmp0[2048 / 8];
    uint32_t u32Len = 2048 / 8;
    
    rsa_pri_key_t privatekey;
    
    //////////////////////////////////1024//////////////////////////////
    
    DBG_PRINT("\nrsa 1024 test\n");

    //mh_rsa_gen_key(&pri_key, 0x10001, 2048, mh_rand_p, NULL);
    memset(&pri_key, 0, sizeof(pri_key));
    memset(&pub_key, 0, sizeof(pub_key));
    memset(&plain, 0, sizeof(plain));
    memset(&cipher, 0, sizeof(cipher));

    rsa_read_key(&pri_key, 1024);
    
    //mh_rsa_complete_key(&pri_key, mh_rand_p, NULL);
#if 0
  
    ouputRes("n_c\n", pri_key.n_c, sizeof(pri_key.n_c));
    ouputRes("n_q\n", pri_key.n_q, sizeof(pri_key.n_q));
    ouputRes("p_c\n", pri_key.p_c, sizeof(pri_key.p_c));
    ouputRes("p_q\n", pri_key.p_q, sizeof(pri_key.p_q));
    ouputRes("q_c\n", pri_key.q_c, sizeof(pri_key.q_c));
    ouputRes("q_q\n", pri_key.q_q, sizeof(pri_key.q_q));
    
    pub_key.bytes = pri_key.bytes;
    memcpy(pub_key.e, pri_key.e, sizeof(pri_key.e));
    memcpy(pub_key.n, pri_key.n, sizeof(pri_key.n));
    memcpy(pub_key.n_c, pri_key.n_c, sizeof(pri_key.n_c));
    memcpy(pub_key.n_q, pri_key.n_q, sizeof(pri_key.n_q));

    bn_read_string_to_bytes(plain, pri_key.bytes, PLAIN_1024);
    bn_read_string_to_bytes(cipher, pri_key.bytes, CIPHER_1024);

    memset(tmp0, 0, pri_key.bytes);
    mh_rsa_private(tmp0, cipher, &pri_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, plain, pri_key.bytes)), "mh_rsa_private test\n");

    
    memset(tmp0, 0, pri_key.bytes);
    mh_rsa_public(tmp0, plain, &pub_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, cipher, pri_key.bytes)), "mh_rsa_public test\n");
    
    memset(tmp0, 0, pri_key.bytes);
    mh_rsa_private_crt(tmp0, cipher, &pri_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, plain, pri_key.bytes)), "mh_rsa_private_crt test\n");
    
    
    
    //////////////////////////////////2048//////////////////////////////
    
    DBG_PRINT("\nrsa 2048 test\n");

    rsa_read_key(&pri_key, 2048);
    
    //mh_rsa_complete_key(&pri_key, mh_rand_p, NULL);
    
    pub_key.bytes = pri_key.bytes;
#endif

    memset(&pub_key, 0, sizeof(pub_key));
    
    pub_key.bytes = 248;
    //pub_key.bytes = (pub_key.bytes + 3)&~0x03;
    pub_key.e[0] = 3;
    bn_read_string_to_bytes((uint8_t *)pub_key.n, sizeof(pub_key.n), N_1);
    bn_read_string_to_bytes((uint8_t *)plain, sizeof(plain), INPUT);
    
    memswap(tmp0, sizeof(tmp0), pub_key.n, pub_key.bytes);
    
    bn_s_get_C((uint32_t *)cipher, (uint32_t *)tmp0, pub_key.bytes >> 2, mh_rand_p, NULL);
    memswap(pub_key.n_c, pub_key.bytes, cipher, pub_key.bytes);
    bn_s_get_Q((uint32_t *)pub_key.n_q, (uint32_t *)tmp0, mh_rand_p, NULL);
    memswap(pub_key.n_q, 4, cipher, pub_key.bytes);
    
    u32Len = mh_rsa_public(tmp0, plain, &pub_key, mh_rand_p, NULL);
    r_printf((0 == memcmp(tmp0, cipher, pri_key.bytes)), "mh_rsa_public test\n");
    DBG_PRINT("\n");

}
#endif











